f3 = function(x, y){
print( match.call() )
}
f3( x=1, y=2 )
f3 = function(x, y){
print( match.call() )
print( is( match.call() ) )
}
f3( x=1, y=2 )
?match.call
f3 = function(x, y){
return( match.call() )
print( is( match.call() ) )
}
f3( x=1, y=2 )
temp = f3( x=1, y=2 )
is( temp )
names( temp )
temp$x
temp = f3( x=a, y=2 )
temp$x
is( temp$x )
as.character( temp$x )
as.character( temp$x )
assign
removeNoInfo = function (data, value, flag, byKey,
environment = parent.frame(1)){
info = data[, rep(containInfo(get(value), get(flag)),
NROW(.SD)), by = byKey]$V1
#Assign the new data.table to environment
dataTableName = match.call()$data
assign( x = dataTableName, value = data[info,],
envir = environment )
}
library(faoswsProductionImputation)
library(faoswsUtil)
library(data.table)
library(lme4)
# library(lattice)
sum = function(x, na.rm=!all(is.na(x)) ){ base::sum(x, na.rm=na.rm) }
files = dir("~/GitHub/sws_imputation/faoswsProductionImputation/R/",
pattern = "\\.R$", full.names = TRUE)
for( file in files)
source(file)
garlic = fread("~/GitHub/sws_imputation/tests/alpha_testing/nicolas/split_data/vegetable_primary/Garlic.csv")
str(okrapd)
is(okrapd)
data = copy(okrapd)
if( ! "yieldFlag2" %in% colnames(data) ){
data$yieldFlag2 = "*"
data$productionFlag2 = "*"
data$areaHarvestedFlag2 = "*"
}
# ggplot(data, aes(x=year, y=areaName, fill=productionFlag)) + geom_tile()
# ggplot(data, aes(x=year, y=areaName, fill=areaHarvestedFlag)) + geom_tile()
# ggplot(data, aes(x=year, y=areaName, fill=yieldFlag)) + geom_tile()
swsOldFlagTable = rbind(faoswsFlagTable, data.frame(flagObservationStatus = c("*", "F"),
flagObservationWeights = c(0.9, 0.6)))
swsOldFlagTable[swsOldFlagTable$flagObservationStatus == "E", "flagObservationWeights"] = 0.55
swsOldFlagTable
## Removing prior imputation for production
table(data$productionFlag)
removeImputation(data = data,
value = "productionValue",
flag = "productionFlag",
imputedFlag = "E",
naFlag = "M")
table(data$productionFlag)
table(data$areaHarvestedFlag)
removeImputation(data = data,
value = "areaHarvestedValue",
flag = "areaHarvestedFlag",
imputedFlag = "E",
naFlag = "M")
table(data$areaHarvestedFlag)
table(data$yieldFlag)
removeImputation(data = data,
value = "yieldValue",
flag = "yieldFlag",
imputedFlag = "E",
naFlag = "M")
table(data$yieldFlag)
remove0M(data = data,
value = "productionValue",
flag = "productionFlag",
naFlag = "M")
data[areaHarvestedFlag=="M",.N,by=areaHarvestedValue]
remove0M(data = data,
value = "areaHarvestedValue",
flag = "areaHarvestedFlag",
naFlag = "M")
data[areaHarvestedFlag=="M",.N,by=areaHarvestedValue]
temp = copy(data)
temp[yieldFlag=="M",.N,by=yieldValue]
#remove0M has side effect on temp
remove0M(data = temp,
value = "yieldValue",
flag = "yieldFlag",
naFlag = "M")
temp = copy(data)
temp[yieldFlag=="M",.N,by=yieldValue]
temp[,containInfo(yieldValue, yieldFlag),by=areaCode]$V1
temp[,containInfo(yieldValue, yieldFlag),by=areaCode]$V1
dim(temp)
removeNoInfo(data = temp,
flag = "yieldFlag",
value = "yieldValue",
byKey = "areaCode")
source('~/GitHub/sws_imputation/faoswsProductionImputation/R/removeNoInfo.R', echo=TRUE)
removeNoInfo(data = temp,
flag = "yieldFlag",
value = "yieldValue",
byKey = "areaCode")
dim( temp )
temp[,containInfo(yieldValue, yieldFlag),by=areaCode]$V1
temp = removeNoInfo(data = temp,
flag = "yieldFlag",
value = "yieldValue",
byKey = "areaCode")
temp
is( temp )
y = removeNoInfo(data = temp,
flag = "yieldFlag",
value = "yieldValue",
byKey = "areaCode")
is( y )
dim( y )
y == temp
is( y )
is( temp )
context
library(testthat)
context("String and pattern checks")
library(stringr)
expect_that(check_string(list()),
throws_error("must be an atomic"))
check_string
library(stringr)
list()
expect_that
throws_error
check_string
stringr::check_string
stringr:::check_string
expect_that(stringr:::check_string(list()),
throws_error("must be an atomic"))
stringr:::check_string(list())
defaultArima(x)
x = 1:10
defaultArima(x)
defaultArima
defaultArima(x)
defaultMean(x)
defaultArima(x)
?expect_that
is( defaultArima(x) )
expect_that(defaultArima(x), is_a(vector) )
expect_that(defaultArima(x), is_a("vector") )
is(x)
expect_that(length( defaultArima(x) ), equals(10) )
models = allDefaultModels()
models
test_that("Models return vectors", {
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
}
)
model = models[1]
model
model[[1]]
for(model in models)
is(model)
for(model in models)
print( is(model) )
for(model in models)
print( model(x) )
models[[6]]
models[[6]](x)
models[[7]](x)
models[[5]](x)
models[[8]](x)
models[[8]]
models = models[-8]
models
x = 1:10
for(model in models)
print( model(x) )
for(model in models)
expect_that(length( model(x) ), equals(10) )
test_that("Models return vectors", {
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
})
models = allDefaultModels()
test_that("Models return vectors", {
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
})
models[[8]]
models[[8]](x)
x
time = 1:length(x)
T = length(x)
T
obs.x = na.omit(x)
obs.time = time[-attr(obs.x, "na.action")]
obs.time
obs.x
time
attr(obs.x, "na.action")
defaultMars( 1:10 )
defaultMars( rnorm(10) )
x = c(1:10, NA)
obs.x = na.omit(x)
obs.x
?na.omit
any( is.na(x) )
source('~/GitHub/sws_imputation/faoswsProductionImputation/R/defaultMars.R', echo=TRUE)
context("Tests for all default* models")
models = allDefaultModels()
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
test_that("Models return vectors", {
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
})
test_that("Models return vectors of appropriate length", {
x = 1:10
for(model in models)
expect_that(length( model(x) ), equals(10) )
})
defaultArima
x = c(rnorm(5), rep(NA,10))
for(model in models)
expect_that(length( model(x) ), equals(10) )
expect_that(length( model(x) ), equals(10) | equals(15) )
equals(10)
?expect_that
na.rm(model(x))
na.omit
na.omit(model(x))
for(model in models)
expect_that(length( na.omit(model(x)) ), equals(15) )
model
for(model in models)
expect_that(
length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0,
is_true )
model
expect_that(
length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0,
is_true )
length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0
expect_that
expect_that(
(length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0 ),
is_true )
expect_that(
object = (length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0 ),
is_true )
expect_that(
{length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0 },
is_true )
is_true
expect_that( length( na.omit(model(x)) ) == 15,
is_true )
model(x)
na.omit(model(x))
length( na.omit(model(x)) ) == 15
expect_that( length( na.omit(model(x)) ) == 15, is_true )
length( model(x) )
?equals
expect_true( length( na.omit(model(x)) ) == 15 )
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
for(model in models)
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
model
model(x)
x
model(x)
x = c(abs(rnorm(5)), rep(NA,10))
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
for(model in models)
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
test_that("Models return vectors of appropriate length", {
x = c(abs(rnorm(5)), rep(NA,10))
for(model in models)
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
})
?glm
is.numeric(x)
x
test_that("Results are all NA or all numeric", {
x = c(abs(rnorm(5)), rep(NA,10))
for(model in models)
expect_true( length( na.omit(model(x)) ) == 15 |
length( na.omit(model(x)) ) == 0  )
})
?snht
data = matrix( rnorm(400), nrow=100 )
data
data = data.frame( data = rnorm(400), location = rep(1:4, times=100) )
data
data = data.frame( data = rnorm(400), location = rep(1:4, each=100) )
data
dist
dist(1:4)
dist = as.matrix( dist(1:4) )
dist
k = 2
period = 20
library(snht)
crit = 100
returnStat = FALSE
stopifnot(is(data,"data.frame"))
if(ncol(data)==2)
stopifnot(colnames(data)==c("data","location"))
if(ncol(data)==3)
stopifnot(colnames(data)==c("data","location","time"))
stopifnot(ncol(data) %in% c(2,3))
locs = as.character(unique(data$location))
stopifnot(all(rownames(dist) %in% locs))
stopifnot(all(colnames(dist) %in% locs))
stopifnot(all(locs %in% rownames(dist)))
stopifnot(all(locs %in% colnames(dist)))
stopifnot(k>=1) #Must have at least one neighbor
stopifnot(k<=length(locs)-1) #Can have at most length(locs)-1 neighbor, since self can't be used
stopifnot(diag(dist)==0)
if(any(dist[row(dist)!=col(dist)]<=0))
stop("Off diagonal elements of dist must be >0")
pairs = lapply(1:nrow(dist), function(i){
x = dist[i,]
filt = rank(x)>1 & rank(x)<=k+1.5
colnames(dist)[filt]
})
names(pairs) = colnames(dist)
pairs
getPairs = function(dist){
pairs = lapply(1:nrow(dist), function(i){
x = dist[i,]
filt = rank(x)>1 & rank(x)<=k+1.5
colnames(dist)[filt]
})
names(pairs) = colnames(dist)
}
getPairs( dist )
getPairs = function(dist){
pairs = lapply(1:nrow(dist), function(i){
x = dist[i,]
filt = rank(x)>1 & rank(x)<=k+1.5
colnames(dist)[filt]
})
names(pairs) = colnames(dist)
return(pairs)
}
getPairs( dist )
pairs = getPairs(dist)
pairs
uniquePairs = data.frame(loc1 = rep(colnames(dist), lapply(pairs,length))
,loc2 = do.call("c", pairs), stringsAsFactors=F )
uniquePairs
pairs
pairs
colnames(dist)
names( pairs )
uniquePairs = data.frame(loc1 = rep(names(pairs), lapply(pairs,length))
,loc2 = do.call("c", pairs), stringsAsFactors=F )
uniquePairs
uniquePairs
is( uniquePairs )
!"time" %in% colnames(data)
length( unique( table( data$location ) ) ) != 1
data$order = 1:nrow(data) #ensure original ordering is preserved
data = plyr::ddply(data, "location", function(df){
df = df[order(df$order),]
df$time = 1:nrow(df)
return(df)
} )
data = reshape::cast(data, formula = time ~ location, value="data")
diffs = data.frame(time=data$time)
diffs
data
locs
names(dist)
dist
rownames(dist)
candidate = matrix(0, nrow=nrow(data), ncol=length(locations))
locations = locs
rm( locs)
candidate = matrix(0, nrow=nrow(data), ncol=length(locations))
colnames(candidate) = locations
statistics
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1], ...)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1])
data = reshape::cast(data, formula = time ~ location, value="data")
diffs = data.frame(time=data$time)
for(i in 1:nrow(uniquePairs)){
diffs = cbind(diffs, data[,uniquePairs[i,1]] - data[,uniquePairs[i,2]])
colnames(diffs)[ncol(diffs)] = paste0(uniquePairs[i,1],"-",uniquePairs[i,2])
}
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1], ...)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1])
avgDiff = do.call("cbind", lapply(statistics, function(x) x$rightMean-x$leftMean ) )
statistics = do.call("cbind", lapply(statistics, function(x) x$score))
if(returnStat)
return(statistics)
j = 1
name = colnames(statistics)[j]
name
name = strsplit(name, "-")[[1]]
name
delta = as.numeric(statistics[,j]>crit)
delta
delta[is.na(delta)] = 0
name[2] %in% pairs[name[1]][[1]]
pairs
if(name[2] %in% pairs[name[1]][[1]])
candidate[,name[2]] = candidate[,name[2]] + delta
if(name[1] %in% pairs[name[2]][[1]])
candidate[,name[1]] = candidate[,name[1]] + delta
candidate = matrix(0, nrow=nrow(data), ncol=length(locations))
colnames(candidate) = locations
for( j in 1:ncol(statistics) ){
name = colnames(statistics)[j]
name = strsplit(name, "-")[[1]]
delta = as.numeric(statistics[,j]>crit)
delta[is.na(delta)] = 0
if(name[2] %in% pairs[name[1]][[1]])
candidate[,name[2]] = candidate[,name[2]] + delta
if(name[1] %in% pairs[name[2]][[1]])
candidate[,name[1]] = candidate[,name[1]] + delta
}
candidate
names(data)
colnames(data)
statistics
pairs
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/createCandidateMatrix.R', echo=TRUE)
candidate = createCandidateMatrix(data, statistics = statistics, pairs = pairs)
candidate
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/createCandidateMatrix.R', echo=TRUE)
candidate = createCandidateMatrix(data, statistics = statistics, pairs = pairs)
candidate
is( candidate )
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/pairwiseSNHT.R', echo=TRUE)
ls()
getwd()
setwd("GitHub/Stan-Norm-Hom-Test/")
setwd("snht")
library(devtools)
document()
document()
?getUniquePairs
document()
document()
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/robustSNHT.R', echo=TRUE)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1], ...)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1])
statistics
snht
getwd()
for(file in list.files("R")) source(paste0("R/", file))
snht
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1], ...)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1])
statistics
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/robustSNHT.R', echo=TRUE)
statistics = apply(diffs[,-1], 2, snht, period=period, time=diffs[,1])
statistics
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/createCandidateMatrix.R', echo=TRUE)
out = unconfoundCandidateMatrix(candidate = candidate, pairs = pairs,
statistics = statistics, data = data)
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/unconfoundCandidateMatrix.R', echo=TRUE)
out = unconfoundCandidateMatrix(candidate = candidate, pairs = pairs,
statistics = statistics, data = data)
out$data
out$data = reshape::melt(out$data, id.vars=c("time"))
rownames(out$data) = NULL
colnames(data)=="value"
colnames(out$data)
colnames(out$data)[colnames(out$data)=="value"] = "data"
out$data = out$data[,c("data", "location", "time")]
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/pairwiseSNHT.R', echo=TRUE)
pairwiseSNHT( data, dist, k, period )
data = data.frame( data = rnorm(400), location = rep(1:4, each=100) )
dist = as.matrix( dist(1:4) )
k = 2
period = 20
crit = 100
returnStat = FALSE
pairwiseSNHT( data, dist, k, period )
k
pairwiseSNHT( data, dist, k=k, period )
getUniquePairs
source('~/GitHub/Stan-Norm-Hom-Test/snht/R/pairwiseSNHT.R', echo=TRUE)
pairwiseSNHT( data, dist, k=k, period )
